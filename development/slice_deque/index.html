<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="A double-ended queue that `Deref`s into a slice."><title>slice_deque - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceSerif4-Regular-46f98efaafac5295.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/FiraSans-Regular-018c141bf0843ffd.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/FiraSans-Medium-8f9a781e4970d388.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceSerif4-Bold-a2c9cd1067f8b328.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2"><link rel="stylesheet" href="../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../static.files/rustdoc-cb6f1f67f1bcd037.css" id="mainThemeStyle"><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="slice_deque" data-themes="" data-resource-suffix="" data-rustdoc-version="1.73.0-nightly (31395ec38 2023-07-24)" data-channel="nightly" data-search-js="search-6dfdfced5eff6596.js" data-settings-js="settings-de11bff964e9d4e5.js" data-settings-css="settings-8c76f75bfb6bd192.css" data-theme-light-css="light-6d2c9675f3d09c26.css" data-theme-dark-css="dark-45ceb8f2e522f4d1.css" data-theme-ayu-css="ayu-fd19013d6ce078bf.css" ><script src="../static.files/storage-db41da1a38ea3cb8.js"></script><script defer src="../crates.js"></script><script defer src="../static.files/main-0795b7d26be81095.js"></script><noscript><link rel="stylesheet" media="(prefers-color-scheme:light)" href="../static.files/light-6d2c9675f3d09c26.css"><link rel="stylesheet" media="(prefers-color-scheme:dark)" href="../static.files/dark-45ceb8f2e522f4d1.css"><link rel="stylesheet" href="../static.files/noscript-cffde32267a19fd6.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-16x16-8b506e7a72182f1c.png"><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="logo-container" href="../slice_deque/index.html"><img class="rust-logo" src="../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><h2></h2></nav><nav class="sidebar"><a class="logo-container" href="../slice_deque/index.html"><img class="rust-logo" src="../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><h2 class="location"><a href="#">Crate slice_deque</a></h2><div class="sidebar-elems"><ul class="block"><li class="version">Version 0.3.0</li><li><a id="all-types" href="all.html">All Items</a></li></ul><section><ul class="block"><li><a href="#macros">Macros</a></li><li><a href="#structs">Structs</a></li><li><a href="#enums">Enums</a></li></ul></section></div></nav><main><div class="width-limiter"><nav class="sub"><form class="search-form"><span></span><input class="search-input" name="search" aria-label="Run search in the documentation" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" title="help" tabindex="-1"><a href="../help.html">?</a></div><div id="settings-menu" tabindex="-1"><a href="../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../static.files/wheel-7b819b6101059cd0.svg"></a></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1>Crate <a class="mod" href="#">slice_deque</a><button id="copy-path" title="Copy item path to clipboard"><img src="../static.files/clipboard-7571035ce49a181d.svg" width="19" height="18" alt="Copy item path"></button></h1><span class="out-of-band"><a class="src" href="../src/slice_deque/lib.rs.html#1-5956">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>A double-ended queue that <code>Deref</code>s into a slice.</p>
<p>The double-ended queue in the standard library (<a href="https://doc.rust-lang.org/std/collections/struct.VecDeque.html"><code>VecDeque</code></a>) is
implemented using a growable ring buffer (<code>0</code> represents uninitialized
memory, and <code>T</code> represents one element in the queue):</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// [ 0 | 0 | 0 | T | T | T | 0 ]
//               ^:head  ^:tail</span></code></pre></div>
<p>When the queue grows beyond the end of the allocated buffer, its tail wraps
around:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// [ T | T | 0 | T | T | T | T ]
//       ^:tail  ^:head</span></code></pre></div>
<p>As a consequence, <a href="https://doc.rust-lang.org/std/collections/struct.VecDeque.html"><code>VecDeque</code></a> cannot <code>Deref</code> into a slice, since its
elements do not, in general, occupy a contiguous memory region. This
complicates the implementation and its interface (for example, there is no
<code>as_slice</code> method, but <a href="https://doc.rust-lang.org/std/collections/struct.VecDeque.html#method.as_slices"><code>as_slices</code></a> returns a pair of slices) and has
negative performance consequences (e.g. need to account for wrap around
while iterating over the elements).</p>
<p>This crates provides <a href="struct.SliceDeque.html"><code>SliceDeque</code></a>, a double-ended queue implemented with
a growable <em>virtual</em> ring-buffer.</p>
<p>A virtual ring-buffer implementation is very similar to the one used in
<code>VecDeque</code>. The main difference is that a virtual ring-buffer maps two
adjacent regions of virtual memory to the same region of physical memory:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// Virtual memory:
//
//  __________region_0_________ __________region_1_________
// [ 0 | 0 | 0 | T | T | T | 0 | 0 | 0 | 0 | T | T | T | 0 ]
//               ^:head  ^:tail
//
// Physical memory:
//
// [ 0 | 0 | 0 | T | T | T | 0 ]
//               ^:head  ^:tail</span></code></pre></div>
<p>That is, both the virtual memory regions <code>0</code> and <code>1</code> above (top) map to
the same physical memory (bottom). Just like <code>VecDeque</code>, when the queue
grows beyond the end of the allocated physical memory region, the queue
wraps around, and new elements continue to be appended at the beginning of
the queue. However, because <code>SliceDeque</code> maps the physical memory to two
adjacent memory regions, in virtual memory space the queue maintais the
ilusion of a contiguous memory layout:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// Virtual memory:
//
//  __________region_0_________ __________region_1_________
// [ T | T | 0 | T | T | T | T | T | T | 0 | T | T | T | T ]
//               ^:head              ^:tail
//
// Physical memory:
//
// [ T | T | 0 | T | T | T | T ]
//       ^:tail  ^:head</span></code></pre></div>
<p>Since processes in many Operating Systems only deal with virtual memory
addresses, leaving the mapping to physical memory to the CPU Memory
Management Unit (MMU), <a href="struct.SliceDeque.html"><code>SliceDeque</code></a> is able to <code>Deref</code>s into a slice in
those systems.</p>
<p>This simplifies <a href="struct.SliceDeque.html"><code>SliceDeque</code></a>’s API and implementation, giving it a
performance advantage over <a href="https://doc.rust-lang.org/std/collections/struct.VecDeque.html"><code>VecDeque</code></a> in some situations.</p>
<p>In general, you can think of <a href="struct.SliceDeque.html"><code>SliceDeque</code></a> as a <code>Vec</code> with <code>O(1)</code>
<code>pop_front</code> and amortized <code>O(1)</code> <code>push_front</code> methods.</p>
<p>The main drawbacks of <a href="struct.SliceDeque.html"><code>SliceDeque</code></a> are:</p>
<ul>
<li>
<p>constrained platform support: by necessity <a href="struct.SliceDeque.html"><code>SliceDeque</code></a> must use the
platform-specific virtual memory facilities of the underlying operating
system. While <a href="struct.SliceDeque.html"><code>SliceDeque</code></a> can work on all major operating systems,
currently only <code>MacOS X</code> is supported.</p>
</li>
<li>
<p>no global allocator support: since the <code>Alloc</code>ator API does not support
virtual memory, to use platform-specific virtual memory support
<a href="struct.SliceDeque.html"><code>SliceDeque</code></a> must bypass the global allocator and talk directly to the
operating system. This can have negative performance consequences since
growing <a href="struct.SliceDeque.html"><code>SliceDeque</code></a> is always going to incur the cost of some system
calls.</p>
</li>
<li>
<p>capacity constrained by virtual memory facilities: <a href="struct.SliceDeque.html"><code>SliceDeque</code></a> must
allocate two adjacent memory regions that map to the same region of
physical memory. Most operating systems allow this operation to be
performed exclusively on memory pages (or memory allocations that are
multiples of a memory page). As a consequence, the smalles <a href="struct.SliceDeque.html"><code>SliceDeque</code></a>
that can be created has typically a capacity of 2 memory pages, and it can
grow only to capacities that are a multiple of a memory page.</p>
</li>
</ul>
<p>The main advantages of <a href="struct.SliceDeque.html"><code>SliceDeque</code></a> are:</p>
<ul>
<li>
<p>nicer API: since it <code>Deref</code>s to a slice, all operations that work on
slices are available for <code>SliceDeque</code>.</p>
</li>
<li>
<p>efficient iteration: as efficient as for slices.</p>
</li>
<li>
<p>simpler serialization: since one can just serialize/deserialize a single
slice.</p>
</li>
</ul>
<p>All in all, if your double-ended queues are small (smaller than a memory
page) or they get resized very often, <code>VecDeque</code> can perform better than
<a href="struct.SliceDeque.html"><code>SliceDeque</code></a>. Otherwise, <a href="struct.SliceDeque.html"><code>SliceDeque</code></a> typically performs better (see
the benchmarks), but platform support and global allocator bypass are two
reasons to weight in against its usage.</p>
</div></details><h2 id="macros" class="small-section-header"><a href="#macros">Macros</a></h2><ul class="item-table"><li><div class="item-name"><a class="macro" href="macro.sdeq.html" title="macro slice_deque::sdeq">sdeq</a></div><div class="desc docblock-short">Creates a <a href="struct.SliceDeque.html"><code>SliceDeque</code></a> containing the arguments.</div></li></ul><h2 id="structs" class="small-section-header"><a href="#structs">Structs</a></h2><ul class="item-table"><li><div class="item-name"><a class="struct" href="struct.Buffer.html" title="struct slice_deque::Buffer">Buffer</a></div><div class="desc docblock-short">Mirrored memory buffer of length <code>len</code>.</div></li><li><div class="item-name"><a class="struct" href="struct.Drain.html" title="struct slice_deque::Drain">Drain</a></div><div class="desc docblock-short">A draining iterator for <code>SliceDeque&lt;T&gt;</code>.</div></li><li><div class="item-name"><a class="struct" href="struct.DrainFilter.html" title="struct slice_deque::DrainFilter">DrainFilter</a></div><div class="desc docblock-short">An iterator produced by calling <code>drain_filter</code> on <code>SliceDeque</code>.</div></li><li><div class="item-name"><a class="struct" href="struct.IntoIter.html" title="struct slice_deque::IntoIter">IntoIter</a></div><div class="desc docblock-short">An iterator that moves out of a deque.</div></li><li><div class="item-name"><a class="struct" href="struct.SliceDeque.html" title="struct slice_deque::SliceDeque">SliceDeque</a></div><div class="desc docblock-short">A double-ended queue that derefs into a slice.</div></li><li><div class="item-name"><a class="struct" href="struct.Splice.html" title="struct slice_deque::Splice">Splice</a></div><div class="desc docblock-short">A splicing iterator for <code>SliceDeque</code>.</div></li></ul><h2 id="enums" class="small-section-header"><a href="#enums">Enums</a></h2><ul class="item-table"><li><div class="item-name"><a class="enum" href="enum.AllocError.html" title="enum slice_deque::AllocError">AllocError</a></div><div class="desc docblock-short">Allocation error.</div></li></ul></section></div></main></body></html>