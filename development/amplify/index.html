<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Amplifying Rust language capabilities: multiple generic trait implementations, type wrappers, derive macros."><title>amplify - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceSerif4-Regular-46f98efaafac5295.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/FiraSans-Regular-018c141bf0843ffd.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/FiraSans-Medium-8f9a781e4970d388.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceSerif4-Bold-a2c9cd1067f8b328.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2"><link rel="stylesheet" href="../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../static.files/rustdoc-cb6f1f67f1bcd037.css" id="mainThemeStyle"><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="amplify" data-themes="" data-resource-suffix="" data-rustdoc-version="1.73.0-nightly (31395ec38 2023-07-24)" data-channel="nightly" data-search-js="search-6dfdfced5eff6596.js" data-settings-js="settings-de11bff964e9d4e5.js" data-settings-css="settings-8c76f75bfb6bd192.css" data-theme-light-css="light-6d2c9675f3d09c26.css" data-theme-dark-css="dark-45ceb8f2e522f4d1.css" data-theme-ayu-css="ayu-fd19013d6ce078bf.css" ><script src="../static.files/storage-db41da1a38ea3cb8.js"></script><script defer src="../crates.js"></script><script defer src="../static.files/main-0795b7d26be81095.js"></script><noscript><link rel="stylesheet" media="(prefers-color-scheme:light)" href="../static.files/light-6d2c9675f3d09c26.css"><link rel="stylesheet" media="(prefers-color-scheme:dark)" href="../static.files/dark-45ceb8f2e522f4d1.css"><link rel="stylesheet" href="../static.files/noscript-cffde32267a19fd6.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-16x16-8b506e7a72182f1c.png"><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="logo-container" href="../amplify/index.html"><img class="rust-logo" src="../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><h2></h2></nav><nav class="sidebar"><a class="logo-container" href="../amplify/index.html"><img class="rust-logo" src="../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><h2 class="location"><a href="#">Crate amplify</a></h2><div class="sidebar-elems"><ul class="block"><li class="version">Version 4.0.0</li><li><a id="all-types" href="all.html">All Items</a></li></ul><section><ul class="block"><li><a href="#reexports">Re-exports</a></li><li><a href="#modules">Modules</a></li><li><a href="#macros">Macros</a></li><li><a href="#structs">Structs</a></li><li><a href="#traits">Traits</a></li><li><a href="#types">Type Definitions</a></li><li><a href="#derives">Derive Macros</a></li></ul></section></div></nav><main><div class="width-limiter"><nav class="sub"><form class="search-form"><span></span><input class="search-input" name="search" aria-label="Run search in the documentation" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" title="help" tabindex="-1"><a href="../help.html">?</a></div><div id="settings-menu" tabindex="-1"><a href="../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../static.files/wheel-7b819b6101059cd0.svg"></a></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1>Crate <a class="mod" href="#">amplify</a><button id="copy-path" title="Copy item path to clipboard"><img src="../static.files/clipboard-7571035ce49a181d.svg" width="19" height="18" alt="Copy item path"></button></h1><span class="out-of-band"><a class="src" href="../src/amplify/lib.rs.html#17-95">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Amplifying Rust language capabilities: multiple generic trait
implementations, type wrappers, derive macros.</p>
<p>Minimum supported rust compiler version (MSRV): 1.46 (stable channel)</p>
</div></details><h2 id="reexports" class="small-section-header"><a href="#reexports">Re-exports</a></h2><ul class="item-table"><li><div class="item-name"><code>pub extern crate <a class="mod" href="../ascii/index.html" title="mod ascii">ascii</a>;</code></div></li><li><div class="item-name" id="reexport.Holder"><code>pub use crate::strategy::<a class="struct" href="strategy/struct.Holder.html" title="struct amplify::strategy::Holder">Holder</a>;</code></div></li></ul><h2 id="modules" class="small-section-header"><a href="#modules">Modules</a></h2><ul class="item-table"><li><div class="item-name"><a class="mod" href="num/index.html" title="mod amplify::num">num</a></div><div class="desc docblock-short">Custom-sized numeric types</div></li><li><div class="item-name"><a class="mod" href="strategy/index.html" title="mod amplify::strategy">strategy</a></div><div class="desc docblock-short">This is a trick for rust compiler helping to distinguish types implementing
mutually-exclusive traits (required until negative trait impls will be
there) Implemented after concept by Martin Habovštiak
<a href="mailto:martin.habovstiak@gmail.com">martin.habovstiak@gmail.com</a></div></li></ul><h2 id="macros" class="small-section-header"><a href="#macros">Macros</a></h2><ul class="item-table"><li><div class="item-name"><a class="macro" href="macro.bmap.html" title="macro amplify::bmap">bmap</a></div><div class="desc docblock-short">Macro for creating [<code>std::collections::BTreeMap</code>] in the same manner as
<code>vec!</code> is used for [<code>Vec</code>]:</div></li><li><div class="item-name"><a class="macro" href="macro.bset.html" title="macro amplify::bset">bset</a></div><div class="desc docblock-short">Macro for creating [<code>std::collections::BTreeSet</code>] in the same manner as
<code>vec!</code> is used for [<code>Vec</code>]:</div></li><li><div class="item-name"><a class="macro" href="macro.default.html" title="macro amplify::default">default</a></div><div class="desc docblock-short">Shorthand for <code>Default::default()</code></div></li><li><div class="item-name"><a class="macro" href="macro.dumb.html" title="macro amplify::dumb">dumb</a></div><div class="desc docblock-short">Shorthand for <code>Dumb::dumb()</code></div></li><li><div class="item-name"><a class="macro" href="macro.empty.html" title="macro amplify::empty">empty</a></div><div class="desc docblock-short">This macro allows more semantically-clear code (which can be used especially
with structure initialization), indicating that instead of type value we are
generating empty collection types</div></li><li><div class="item-name"><a class="macro" href="macro.list.html" title="macro amplify::list">list</a></div><div class="desc docblock-short">Macro for creating [<code>std::collections::LinkedList</code>] in the same manner as
<code>vec!</code> is used for [<code>Vec</code>]:</div></li><li><div class="item-name"><a class="macro" href="macro.map.html" title="macro amplify::map">map</a></div><div class="desc docblock-short">Macro for creating [<code>std::collections::HashMap</code>] in the same manner as
<code>vec!</code> is used for [<code>Vec</code>]:</div></li><li><div class="item-name"><a class="macro" href="macro.none.html" title="macro amplify::none">none</a></div><div class="desc docblock-short">This macro allows more semantically-clear code (which can be used especially
with structure initialization), indicating that instead of type value we are
generating no value at all (empty collection or data structure filled with
information indicating absence of data)</div></li><li><div class="item-name"><a class="macro" href="macro.s.html" title="macro amplify::s">s</a></div><div class="desc docblock-short">Macro for quick &amp; simple <code>&amp;str</code> -&gt; <code>String</code> conversion:</div></li><li><div class="item-name"><a class="macro" href="macro.set.html" title="macro amplify::set">set</a></div><div class="desc docblock-short">Macro for creating [<code>std::collections::HashSet</code>] in the same manner as
<code>vec!</code> is used for [<code>Vec</code>]:</div></li><li><div class="item-name"><a class="macro" href="macro.zero.html" title="macro amplify::zero">zero</a></div><div class="desc docblock-short">This macro allows more semantically-clear code (which can be used especially
with structure initialization), indicating that instead of type value we are
generating zero values (int types or byte slices filled with zeros)</div></li></ul><h2 id="structs" class="small-section-header"><a href="#structs">Structs</a></h2><ul class="item-table"><li><div class="item-name"><a class="struct" href="struct.Array.html" title="struct amplify::Array">Array</a></div><div class="desc docblock-short">Wrapper type for all fixed arrays implementing many important
traits, so types based on it can simply derive their implementations.</div></li></ul><h2 id="traits" class="small-section-header"><a href="#traits">Traits</a></h2><ul class="item-table"><li><div class="item-name"><a class="trait" href="trait.AsAny.html" title="trait amplify::AsAny">AsAny</a></div><div class="desc docblock-short">Trait <code>AsAny</code> allows simple conversion of any type into a generic “thick”
pointer <code>&amp;dyn Any</code> (see <a href="https://doc.rust-lang.org/nightly/core/any/trait.Any.html" title="trait core::any::Any"><code>::core::any::Any</code></a>), that can be later converted
back to the original type with a graceful failing for all other conversions.
For simple conversions it is recommended to use <code>#[derive(AsAny)]</code> macro
from <code>amplify_derive</code> crate (see <a href="derive.AsAny.html" title="derive amplify::AsAny"><code>amplify_derive::AsAny</code></a>).</div></li><li><div class="item-name"><a class="trait" href="trait.Dumb.html" title="trait amplify::Dumb">Dumb</a></div><div class="desc docblock-short">Used as an alternative to default for test and prototyping purposes, when a
type can’t have a default value, but you need to generate some dumb data.</div></li><li><div class="item-name"><a class="trait" href="trait.JoinSplit.html" title="trait amplify::JoinSplit">JoinSplit</a></div><div class="desc docblock-short">Trait for splittable streams and other types, which can be separated into
some two types (<a href="trait.JoinSplit.html#associatedtype.A" title="associated type amplify::JoinSplit::A"><code>JoinSplit::A</code></a>, <a href="trait.JoinSplit.html#associatedtype.B" title="associated type amplify::JoinSplit::B"><code>JoinSplit::B</code></a>), like a reader and
writer streams.</div></li><li><div class="item-name"><a class="trait" href="trait.RawArray.html" title="trait amplify::RawArray">RawArray</a></div><div class="desc docblock-short">Trait which does a blanket implementation for all types wrapping <a href="struct.Array.html" title="struct amplify::Array"><code>Array</code></a>s</div></li><li><div class="item-name"><a class="trait" href="trait.Wrapper.html" title="trait amplify::Wrapper">Wrapper</a></div><div class="desc docblock-short">Trait defining wrapped types (“newtypes” in rust terminology). Wrapped
types are used for allowing implemeting foreign traits to foreign types:
<a href="https://doc.rust-lang.org/stable/rust-by-example/generics/new_types.html">https://doc.rust-lang.org/stable/rust-by-example/generics/new_types.html</a></div></li><li><div class="item-name"><a class="trait" href="trait.WrapperMut.html" title="trait amplify::WrapperMut">WrapperMut</a></div><div class="desc docblock-short">Trait allowing mutable reference borrowing for the wrapped inner type.</div></li></ul><h2 id="types" class="small-section-header"><a href="#types">Type Definitions</a></h2><ul class="item-table"><li><div class="item-name"><a class="type" href="type.Bytes16.html" title="type amplify::Bytes16">Bytes16</a></div><div class="desc docblock-short">Wrapper type for all slice-based 128-bit types implementing many important
traits, so types based on it can simply derive their implementations.</div></li><li><div class="item-name"><a class="type" href="type.Bytes32.html" title="type amplify::Bytes32">Bytes32</a></div><div class="desc docblock-short">Wrapper type for all slice-based 256-bit types implementing many important
traits, so types based on it can simply derive their implementations.</div></li><li><div class="item-name"><a class="type" href="type.Bytes64.html" title="type amplify::Bytes64">Bytes64</a></div><div class="desc docblock-short">Wrapper type for all slice-based 512-bit types implementing many important
traits, so types based on it can simply derive their implementations.</div></li></ul><h2 id="derives" class="small-section-header"><a href="#derives">Derive Macros</a></h2><ul class="item-table"><li><div class="item-name"><a class="derive" href="derive.AsAny.html" title="derive amplify::AsAny">AsAny</a></div><div class="desc docblock-short">Trait <code>amplify::AsAny</code> allows simple conversion of any type into a
generic “thick” pointer <code>&amp;dyn Any</code> (see [<code>::core::any::Any</code>]), that can be
later converted back to the original type with a graceful failing for all
other conversions. <code>AsAny</code> derive macro allows to implement this trait for
arbitrary time without much hussle:</div></li><li><div class="item-name"><a class="derive" href="derive.Display.html" title="derive amplify::Display">Display</a></div><div class="desc docblock-short">Usage</div></li><li><div class="item-name"><a class="derive" href="derive.Error.html" title="derive amplify::Error">Error</a></div><div class="desc docblock-short">Error derive macro works to the full extend only when other derive macros
are used. With <code>#[derive(Display)]</code> and <code>[display(doc_comments)]</code> it uses
doc comments for generating error descriptions; with <code>#[derive(From)]</code> it
may automatically implement transofrations from other error types.</div></li><li><div class="item-name"><a class="derive" href="derive.From.html" title="derive amplify::From">From</a></div><div class="desc docblock-short">Implements <a href="derive.From.html" title="derive amplify::From"><code>From</code></a> trait for the whole entity and/or its separate fields.
Works well with <code>#[derive(Error)]</code> and, in many cases may require
[<code>Default</code>] implementation (for details, pls see Examples below)</div></li><li><div class="item-name"><a class="derive" href="derive.Getters.html" title="derive amplify::Getters">Getters</a></div><div class="desc docblock-short">Derives getter methods for structures. The return type and naming of the
methods depends on the provided attribute arguments.</div></li><li><div class="item-name"><a class="derive" href="derive.Wrapper.html" title="derive amplify::Wrapper">Wrapper</a></div><div class="desc docblock-short">Creates rust new type wrapping existing type. Can be used in structures
containing multiple named or unnamed fields; in this case the field you’d
like to wrap should be marked with <code>#[wrap]</code> attribute; otherwise the first
field is assumed to be the wrapped one.</div></li><li><div class="item-name"><a class="derive" href="derive.WrapperMut.html" title="derive amplify::WrapperMut">WrapperMut</a></div><div class="desc docblock-short">Derives <a href="derive.WrapperMut.html" title="derive amplify::WrapperMut"><code>WrapperMut</code></a> and allows deriving other traits accessing the
wrapped type which require mutable access to the inner type. Requires that
the type already implements <code>amplify::Wrapper</code>.</div></li></ul></section></div></main></body></html>